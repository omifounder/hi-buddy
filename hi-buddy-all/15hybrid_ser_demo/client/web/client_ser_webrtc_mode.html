<!doctype html><html><head><meta charset="utf-8"/><title>SER Demo Client</title>
<style>body{font-family:Arial;margin:12px}button{padding:8px 12px;margin-right:8px}select{padding:6px}#log{white-space:pre-wrap;background:#f4f6fb;padding:8px;border-radius:8px;min-height:160px}</style>
</head><body>
<h3>SER Demo â€” Local/Cloud/Hybrid Mode (client)</h3>
<select id="mode">
  <option value="local">Local (client TFJS)</option>
  <option value="rest">REST (server)</option>
</select>
<button id="start">Start</button>
<button id="stop" disabled>Stop</button>
<div id="status">idle</div>
<pre id="log"></pre>

<script>
const startBtn = document.getElementById('start'), stopBtn = document.getElementById('stop');
const status = document.getElementById('status'), log = document.getElementById('log');
let stream, audioCtx, proc, buffers=[];

function logmsg(s){ log.textContent = (new Date().toISOString()) + " " + s + "\n" + log.textContent; }

startBtn.onclick = async () => {
  startBtn.disabled = true; stopBtn.disabled = false;
  const mode = document.getElementById('mode').value;
  status.textContent = "starting ("+mode+")";
  stream = await navigator.mediaDevices.getUserMedia({audio:true});
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const src = audioCtx.createMediaStreamSource(stream);
  proc = audioCtx.createScriptProcessor(4096,1,1);
  src.connect(proc); proc.connect(audioCtx.destination);
  proc.onaudioprocess = (e) => {
    const d = e.inputBuffer.getChannelData(0);
    buffers.push(new Float32Array(d));
    const total = buffers.reduce((s,b)=>s+b.length,0);
    if(total >= audioCtx.sampleRate*1.0) {
      const out = new Float32Array(total);
      let p=0; for(const b of buffers){ out.set(b,p); p+=b.length; }
      buffers=[];
      if(mode === 'rest') sendWavToServer(out, audioCtx.sampleRate);
      else if (mode === 'local') logmsg('localInfer placeholder - implement TFJS inference');
    }
  };
};

stopBtn.onclick = () => {
  if(proc){ proc.disconnect(); proc=null; }
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  startBtn.disabled=false; stopBtn.disabled=true; status.textContent='idle';
};

function floatToWavBuffer(float32Array, sampleRate){
  const l=float32Array.length;
  const buffer = new ArrayBuffer(44 + l*2);
  const view = new DataView(buffer);
  function writeString(view, offset, string){
    for(let i=0;i<string.length;i++) view.setUint8(offset+i, string.charCodeAt(i));
  }
  writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + l*2, true);
  writeString(view, 8, 'WAVE'); writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate*2, true);
  view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeString(view,36,'data');
  view.setUint32(40, l*2, true);
  let offset=44;
  for(let i=0;i<l;i++){
    let s=Math.max(-1,Math.min(1,float32Array[i]));
    view.setInt16(offset, s<0? s*0x8000 : s*0x7FFF, true); offset+=2;
  }
  return buffer;
}

async function sendWavToServer(float32Samples, sampleRate){
  const targetRate = 16000;
  let samples = float32Samples;
  if(sampleRate !== targetRate){
    const ratio = sampleRate/targetRate;
    const newLen = Math.floor(samples.length/ratio);
    const out = new Float32Array(newLen);
    for(let i=0;i<newLen;i++) out[i]=samples[Math.floor(i*ratio)];
    samples=out;
  }
  const wavBuf = floatToWavBuffer(samples, targetRate);
  const blob = new Blob([wavBuf], {type:'audio/wav'});
  const form = new FormData();
  form.append('file', blob, 'chunk.wav');
  status.textContent = 'sending chunk';
  try {
    const r = await fetch('/infer_wav', { method:'POST', body: form });
    const j = await r.json();
    logmsg('server result: ' + JSON.stringify(j));
  } catch(e){
    logmsg('send failed: ' + e);
  }
}
</script>
</body></html>
